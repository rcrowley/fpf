#!/bin/sh

#/ Usage: fpf-install [--no-deps] [--prefix=<prefix>] <package>
#/   --prefix=<prefix> installation prefix
#/   <package>         package pathname

set -e

. "$(dirname "$(dirname "$0")")/lib/fpf.sh"

# The default is to manage dependencies.
DEPS=1

# The default prefix is the one in which the FPF tools are installed.
PREFIX="$(dirname "$(dirname "$0")")"

usage() {
	grep "^#/" "$0" | cut -c4- 1>&2
	exit "$1"
}
while [ "$#" -gt 0 ]
do
	case "$1" in
		--deps) DEPS=1 shift;;
		--no-deps) DEPS=0 shift;;
		--prefix) PREFIX="$2" shift 2;;
		--prefix=*) PREFIX="$(echo "$1" | cut -c10-)" shift;;
		-h|--help) usage 0;;
		-*) usage 1;;
		*) break;;
	esac
done
PACKAGE="$1"
[ -z "$PREFIX" -o -z "$PACKAGE" ] && usage 1

# It's critical that the prefix be fully-qualified or Git will lose track
# of itself by changing its working directory.
PREFIX="$(cd "$PREFIX" && pwd)"

# Extract the package and its metadata into a temporary directory, which
# will be cleaned up at exit.  Check that the metadata necessary for all
# FPF packages is present using the temporary `GIT_DIR`.
LIB="$PREFIX/lib/fpf"
mkdir -p "$LIB"
TMP="$(mktemp -d --tmpdir="$LIB")"
export GIT_DIR="$TMP"
trap "rm -rf \"$TMP\"" EXIT INT TERM
tar xf "$PACKAGE" -C "$TMP"
ARCH="$(git config "fpf.arch" || true)"
[ -n "$ARCH" -a "$ARCH" != "$(fpf_arch)" ] &&
echo "fpf: $PACKAGE is for $ARCH, not $(fpf_arch)" >&2 && exit 1
NAME="$(git config "fpf.name" || true)"
[ -z "$NAME" ] && echo "fpf: $PACKAGE has no name" >&2 && exit 1
VERSION="$(git config "fpf.version" || true)"
[ -z "$VERSION" ] && echo "fpf: $PACKAGE has no version" >&2 && exit 1

# Verify that no version of this package is already installed in this prefix.
# Export `GIT_DIR` for subsequent `git`(1) commands.
export GIT_DIR="$LIB/$NAME.git"
if [ -d "$GIT_DIR" ]
then
	INST_VERSION="$(git config "fpf.version")"
	echo "fpf: $NAME $INST_VERSION already installed" >&2 && exit 1
fi

# Now that the name of the package is known, move it into the appropriate
# place in FPF's library directory.
mv "$TMP" "$GIT_DIR"

# Create a temporary file to hold rollback information.  Commands listed
# in this file will be run and then the file will be cleaned up on exit.
TMP="$(mktemp)"
echo "rm -rf \"$GIT_DIR\"" >"$TMP"
trap "tac \"$TMP\" | sh; rm -f \"$TMP\"" EXIT INT TERM

# TODO Make dependencies that weren't already satisfied eligible for rollback.
# TODO Installing the newest version is not guaranteed to satisfy a dependency.

# Install dependencies from system package managers (APT and Yum) if those
# package managers are present on this system.
if which apt-get >"/dev/null" 2>"/dev/null" &&
which dpkg >"/dev/null" 2>"/dev/null"
then
	fpf_git_config_prefix "fpf.apt." | while read NAME OPERATOR VERSION
	do
		case "$OPERATOR" in
			">=")
				dpkg --compare-versions "$(
					fpf_dpkg_version "$NAME"
				)" ge "$VERSION" ||
				fpf_if_deps sudo apt-get -q -y install "$NAME"
				fpf_if_deps -q dpkg --compare-versions "$(
					fpf_dpkg_version "$NAME"
				)" ge "$VERSION";;
			"==") fpf_if_deps sudo apt-get -q -y install "$NAME=$VERSION";;
		esac
	done
fi
if which yum >"/dev/null" 2>"/dev/null" &&
which rpm >"/dev/null" 2>"/dev/null"
then
	fpf_git_config_prefix "fpf.yum." | while read NAME OPERATOR VERSION
	do
		case "$OPERATOR" in
			">=")
				fpf_rpmvercmp "$(fpf_rpm_version "$NAME")" ">=" "$VERSION" ||
				fpf_if_deps sudo yum install "$NAME"
				fpf_if_deps -q fpf_rpmvercmp "$(
					fpf_rpm_version "$NAME"
				)" ">=" "$VERSION";;
			"==") fpf_if_deps sudo yum install "$NAME-$VERSION";;
		esac
	done
fi

# Install dependencies from language-level package managers (RubyGems, etc.).
# These package managers must exist on `$PATH`
fpf_git_config_prefix "fpf.cpan." | while read NAME OPERATOR VERSION
do
	[ "$OPERATOR" != ">=" -a "$VERSION" != 0 ] &&
	echo "fpf: CPAN can only install the latest version" >&2
	fpf_if_deps cpan install "$NAME"
done
fpf_git_config_prefix "fpf.gem." | while read NAME OPERATOR VERSION
do
	[ "$OPERATOR" != ">=" ] && V="$VERSION" || V=">= $VERSION"
	gem list -i -q -v"$V" "$NAME" >"/dev/null" ||
	fpf_if_deps sudo gem install -v"$V" "$NAME"
done
fpf_git_config_prefix "fpf.npm." | while read NAME OPERATOR VERSION
do
	mkdir -p "$PREFIX/lib"
	cd "$PREFIX/lib"
	case "$OPERATOR" in
		">=") fpf_if_deps npm install "$NAME@>=$VERSION";;
		"==") fpf_if_deps npm install "$NAME@$VERSION";;
	esac
	cd "-"
done
fpf_git_config_prefix "fpf.pear." | while read NAME OPERATOR VERSION
do
	case "$OPERATOR" in
		">=") fpf_if_deps sudo pear install "$NAME";;
		"==") fpf_if_deps sudo pear install "$NAME-$VERSION";;
	esac
done
fpf_git_config_prefix "fpf.pecl." | while read NAME OPERATOR VERSION
do
	case "$OPERATOR" in
		">=") fpf_if_deps sudo pecl install "$NAME";;
		"==") fpf_if_deps sudo pecl install "$NAME-$VERSION";;
	esac
done
fpf_git_config_prefix "fpf.pip." | while read NAME OPERATOR VERSION
do
	case "$OPERATOR" in
		">=") fpf_if_deps sudo pip install "$NAME";;
		"==") fpf_if_deps sudo pip install "$NAME==$VERSION";;
	esac
done

# Install dependencies from FPR, the APT to FPF's dpkg.
fpf_git_config_prefix "fpf.fpr." | while read NAME OPERATOR VERSION
do
	case "$OPERATOR" in
		">=") fpf_if_deps fpr-install --prefix="$PREFIX" -m"$VERSION" "$NAME";;
		"==") fpf_if_deps fpr-install --prefix="$PREFIX" -v"$VERSION" "$NAME";;
	esac
done

# Checkout a woring copy of the package in FPF's library.  `git-status`(1)
# and `git-diff-files`(1) are now able to verify the integrity of the package.
# Files must not exist or the installation will be rolled back.  Each file
# and directory created are added to the rollback procedure.
COMMIT="$(git rev-parse "HEAD")"
TREE="$(git show --pretty="format:%T" "$COMMIT" | head -n1)"
fpf_git_ls "$TREE" | while read MODE TYPE SHA PATHNAME
do
	MODE="$(echo -n "$MODE" | tail -c4)"
	case "$TYPE" in
		"blob")
			[ -f "$PREFIX/$PATHNAME" ] &&
			echo "fpf: $PREFIX/$PATHNAME already installed" >&2 && exit 1
			git cat-file "blob" "$SHA" >"$PREFIX/$PATHNAME"
			chmod "$MODE" "$PREFIX/$PATHNAME"
			echo "rm \"$PREFIX/$PATHNAME\"";;
		"tree")
			mkdir -m"$MODE" -p "$PREFIX/$PATHNAME"
			echo "rmdir --ignore-fail-on-non-empty \"$PREFIX/$PATHNAME\"";;
	esac
done >>"$TMP"

# Now the repository is non-bare, though the working copy is intermingled
# with other packages installed under this prefix.
git config --bool "core.bare" "false"
export GIT_WORK_TREE="$PREFIX"

# Update Git's index, which enables Git's typical working copy integrity
# checks.  Without these commands, the index file contains null bytes for
# all the `stat`(2) fields stored in the index.
git reset >"/dev/null"
git update-index --refresh

# Verify the installation's integrity for good measure.  This isn't strictly
# necessary but it's a good sanity check for `fpf-check`(1).
$(dirname "$0")/fpf-check --prefix="$PREFIX" "$NAME" >"/dev/null"

# Success!  Cancel installation rollback.
truncate -s"0" "$TMP"
