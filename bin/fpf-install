#!/bin/sh

#/ Usage: fpf-install [--prefix=<prefix>] <package>
#/   --prefix=<prefix> installation prefix
#/   <package>         package pathname

set -e

# The default prefix is the one in which the FPF tools are installed.
PREFIX="$(dirname "$(dirname "$0")")"

usage() {
	grep "^#/" "$0" | cut -c4- 1>&2
	exit "$1"
}
while [ "$#" -gt 0 ]
do
	case "$1" in
		--prefix) PREFIX="$2" shift 2;;
		--prefix=*) PREFIX="$(echo "$1" | cut -c10-)" shift;;
		-h|--help) usage 0;;
		-*) usage 1;;
		*) break;;
	esac
done
PACKAGE="$1"
[ -z "$PREFIX" -o -z "$PACKAGE" ] && usage 1

# It's critical that the prefix be fully-qualified or Git will lose track
# of itself by changing its working directory.
PREFIX="$(cd "$PREFIX" && pwd)"

# Extract the package and its metadata into a temporary directory, which
# will all be cleaned up at exit.  Export `GIT_DIR` for subsequent `git`(1)
# commands.
TMP="$(mktemp -d)"
trap "rm -rf \"$TMP\"" EXIT INT TERM
mkdir "$TMP/work.git"
tar xf "$PACKAGE" -C "$TMP/work.git"
export GIT_DIR="$TMP/work.git"
NAME="$(git config "fpf.name")"
[ -z "$NAME" ] && echo "fpf: $PACKAGE has no name" >&2 && exit 1
VERSION="$(git config "fpf.version")"
[ -z "$VERSION" ] && echo "fpf: $PACKAGE has no version" >&2 && exit 1

# Verify that no version of this package is already installed in this prefix.
LIB="$PREFIX/lib/fpf"
mkdir -p "$LIB"
if [ -d "$LIB/$NAME" ]
then
	INST_VERSION="$(git --git-dir "$LIB/$NAME/.git" config "fpf.version")"
	echo "fpf: $NAME $INST_VERSION already installed" >&2 && exit 1
fi

# Copy the package contents into FPF's library.  This is a staging location
# that's used throughout the lifetime of the package to verify its integrity.
# Export `GIT_DIR` and `GIT_WORK_TREE` for subsequent `git`(1) commands and
# turn this repository non-bare.  The working copy will be populated shortly.
mkdir "$LIB/$NAME"
cp -R "$TMP/work.git" "$LIB/$NAME/.git"
export GIT_DIR="$LIB/$NAME/.git"
export GIT_WORK_TREE="$LIB/$NAME"
git config --bool "core.bare" "false"

. "$(dirname "$(dirname "$0")")/lib/fpf.sh"

# Checkout a working copy of the package in FPF's library.  `git-status`(1)
# and `git-diff-files`(1) are now able to verify the integrity of the package.
COMMIT="$(git rev-parse "HEAD")"
TREE="$(git show --pretty="format:%T" "$COMMIT" | head -n1)"
_git_checkout_tree "$TREE" "$GIT_WORK_TREE"

# Install the package in this prefix by creating directories and hard linking
# regular files from the working copy.  By verifying that the hard links
# are intact and the working copy is in order, the installation's integrity
# may be verified.
find "$LIB/$NAME" -mindepth 1 -name ".git" -prune -o -type d -printf '%P\n' |
while read PATHNAME
do mkdir -m"$(stat -c"%a" "$LIB/$NAME/$PATHNAME")" "$PREFIX/$PATHNAME"
done
find "$LIB/$NAME" -mindepth 1 -name ".git" -prune -o -type f -printf '%P\n' |
while read PATHNAME
do ln "$LIB/$NAME/$PATHNAME" "$PREFIX/$PATHNAME"
done

# Update Git's index, which enables Git's typical working copy integrity
# checks.  Without these commands, the index file contains null bytes for
# all the `stat`(2) fields stored in the index.
git reset >"/dev/null"
git update-index --refresh

# Verify the installation's integrity for good measure.  This isn't strictly
# necessary but it's a good sanity check for `fpf-check`(1).
$(dirname "$0")/fpf-check --prefix="$PREFIX" "$NAME" >"/dev/null"
