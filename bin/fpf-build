#!/bin/sh

#/ Usage: fpf-build [-A|-a<arch>] -d<dirname>|-g<treeish> -n<name> -v<version> <package>
#/   -A          package is architecture-independent
#/   -a<arch>    pointer size (32 or 64) on target systems
#/   -d<dirname> directory to package
#/   -g<treeish> tree or commit to package
#/   -n<name>    package name
#/   -v<version> package version number
#/   <package>   package pathname

set -e

# The default architecture is this architecture.  This may be overridden with
# `-a` or omitted (which means the package runs on any architecture with `-A`.
ARCH="$({ dpkg --print-architecture || rpm --eval "%_arch"; } 2>"/dev/null")"

usage() {
	grep "^#/" "$0" | cut -c4- 1>&2
	exit "$1"
}
while [ "$#" -gt 0 ]
do
	case "$1" in
		-A) ARCH="" shift;;
		-a|--arch) ARCH="$2" shift 2;;
		-a*) ARCH="$(echo $1 | cut -c3-)" shift;;
		--arch=*) ARCH="$(echo $1 | cut -c8-)" shift;;
		-d|--dirname) DIRNAME="$2" shift 2;;
		-d*) DIRNAME="$(echo $1 | cut -c3-)" shift;;
		--dirname=*) DIRNAME="$(echo $1 | cut -c11-)" shift;;
		-g|--git) TREEISH="$2" shift 2;;
		-g*) TREEISH="$(echo $1 | cut -c3-)" shift;;
		--git=*) TREEISH="$(echo $1 | cut -c7-)" shift;;
		-n|--name) NAME="$2" shift 2;;
		-n*) NAME="$(echo $1 | cut -c3-)" shift;;
		--name=*) NAME="$(echo $1 | cut -c8-)" shift;;
		-v|--version) VERSION="$2" shift 2;;
		-v*) VERSION="$(echo $1 | cut -c3-)" shift;;
		--version=*) VERSION="$(echo $1 | cut -c11-)" shift;;
		-h|--help) usage 0;;
		-*) usage 1;;
		*) break;;
	esac
done
PACKAGE="$1"
[ -z "$DIRNAME" -a -z "$TREEISH" -o -n "$DIRNAME" -a -n "$TREEISH" ] && usage 1
[ -z "$NAME" -o -z "$VERSION" -o -z "$PACKAGE" ] && usage 1

# Create a temporary directory, which will be cleaned up at exit.
TMP="$(mktemp -d)"
trap "rm -rf \"$TMP\"" EXIT INT TERM

# If the files being packaged are coming from a Git repository, translate
# this into a directory via `git-archive`(1).  This is a dubious feature
# since the vast majority of Git repositories contain files like README
# which would cause conflicts when a second package was installed on the
# same prefix.
if [ -z "$DIRNAME" ]
then
	DIRNAME="$TMP/work"
	mkdir "$DIRNAME"
	git archive --format="tar" "$TREEISH" | tar xC "$DIRNAME"
fi

# Create a bare Git repository in the temporary directory.  Even the default
# bare Git repository has files FPF doesn't need, so those are removed early.
# Export `GIT_DIR` for subsequent `git`(1) commands.
git init --bare -q "$TMP/work.git"
rm -rf \
	"$TMP/work.git/branches" \
	"$TMP/work.git/hooks" \
	"$TMP/work.git/info" \
	"$TMP/work.git/logs" \
	"$TMP/work.git/objects/info" \
	"$TMP/work.git/objects/pack" \
	"$TMP/work.git/refs/tags"
export GIT_DIR="$TMP/work.git"

# Set `fpf.arch`, `fpf.name`, and `fpf.version` with `git-config`(1).  Git's
# `config` file is used to store package metadata.
[ -z "$ARCH" ] || git config --add "fpf.arch" "$ARCH"
git config --add "fpf.name" "$NAME"
git config --add "fpf.version" "$VERSION"
# TODO User-specified $TMP/work.git/description.

. "$(dirname "$(dirname "$0")")/lib/fpf.sh"

# Write to Git's object store and update `HEAD` to point to the commit and
# tree just created.
TREE="$(_git_write_tree "$DIRNAME")"
COMMIT="$(_git_commit "$TREE")"
git update-ref "refs/heads/$NAME" "$COMMIT"
git symbolic-ref "HEAD" "refs/heads/$NAME"

# Wrap the package in a `tar`(5) archive.
tar cf "$PACKAGE" -C "$TMP/work.git" "."
